package com.sovdee.skriptparticles.shapes;

import com.sovdee.skriptparticles.util.MathUtil;
import org.bukkit.util.Vector;
import org.jetbrains.annotations.Contract;

import java.util.LinkedHashSet;
import java.util.Set;

/**
 * A helix is a spiral that is generated by rotating a line around a central axis.
 * The slope of the helix is the rise of the helix per radian of rotation.
 * The radius of the helix is the distance from the central point to the line.
 * The height of the helix is the distance from the start of the line to the end of the line.
 * The direction of the helix is the direction of rotation.
 */
public class Helix extends AbstractShape implements RadialShape, LWHShape {

    private double radius;
    private double height;
    private double slope;
    private int direction = 1;

    /**
     * Creates a helix with the given radius, height, and slope. Defaults to a clockwise rotation.
     * @param radius the radius of the helix. Must be greater than 0.
     * @param height the height of the helix. Must be greater than 0.
     * @param slope the slope of the helix. Must be greater than 0.
     */
    public Helix(double radius, double height, double slope) {
        super();
        this.radius = Math.max(radius, MathUtil.EPSILON);
        this.height = Math.max(height, MathUtil.EPSILON);
        this.slope = Math.max(slope, MathUtil.EPSILON);
    }

    /**
     * Creates a helix with the given radius, height, slope, and direction.
     * @param radius the radius of the helix. Must be greater than 0.
     * @param height the height of the helix. Must be greater than 0.
     * @param slope the slope of the helix. Must be greater than 0.
     * @param direction the direction of the helix. Must be 1 or -1.
     * @throws IllegalArgumentException if the direction is not 1 or -1.
     */
    public Helix(double radius, double height, double slope, int direction) {
        super();
        this.radius = Math.max(radius, MathUtil.EPSILON);
        this.height = Math.max(height, MathUtil.EPSILON);
        this.slope = Math.max(slope, MathUtil.EPSILON);
        if (direction != 1 && direction != -1)
            throw new IllegalArgumentException("Direction must be 1 or -1");
        this.direction = direction;
    }

    @SuppressWarnings("ConstantConditions")
    @Override
    @Contract(pure = true)
    public void generateOutline(Set<Vector> points) {
        points.addAll(MathUtil.calculateHelix(radius, height, slope, direction, this.getParticleDensity()));
    }

    @SuppressWarnings("ConstantConditions")
    @Override
    @Contract(pure = true)
    public void generateSurface(Set<Vector> points) {
        double particleDensity = this.getParticleDensity();
        for (double r = radius; r > 0; r -= particleDensity) {
            points.addAll(MathUtil.calculateHelix(r, height, slope, direction, particleDensity));
        }
    }

    @Override
    public void setParticleCount(int particleCount) {
        particleCount = Math.max(particleCount, 1);
        this.setParticleDensity(switch (this.getStyle()) {
            case OUTLINE -> (Math.sqrt(slope * slope + radius * radius) * (height / slope) / particleCount);
            case FILL, SURFACE -> Math.sqrt(slope * slope + radius * radius * (height / slope) / particleCount);
        });
    }

    /**
     * The slope of the helix is the rise of the helix per radian of rotation.
     * @return the slope of the helix. Always greater than 0.
     */
    public double getSlope() {
        return slope;
    }

    /**
     * The slope of the helix is the rise of the helix per radian of rotation.
     * @param slope the slope of the helix. Must be greater than 0.
     */
    public void setSlope(double slope) {
        this.slope = Math.max(slope, MathUtil.EPSILON);
        this.setNeedsUpdate(true);
    }

    /**
     * The direction of the helix is the direction of rotation.
     * @return the direction of the helix. 1 for clockwise, -1 for counterclockwise.
     */
    public int getDirection() {
        return direction;
    }

    /**
     * The direction of the helix is the direction of rotation.
     * @param direction the direction of the helix. 1 for clockwise, -1 for counterclockwise.
     * @throws IllegalArgumentException if the direction is not 1 or -1.
     */
    public void setDirection(int direction) {
        if (direction != 1 && direction != -1)
            throw new IllegalArgumentException("Direction must be 1 or -1");
        this.direction = direction;
        this.setNeedsUpdate(true);
    }

    @Override
    public double getLength() {
        return height;
    }

    @Override
    public void setLength(double length) {
        height = Math.max(length, MathUtil.EPSILON);
        this.setNeedsUpdate(true);
    }

    @Override
    public double getWidth() {
        return 0;
    }

    @Override
    public void setWidth(double width) {
        // intentionally empty
    }

    @Override
    public double getHeight() {
        return height;
    }

    @Override
    public void setHeight(double height) {
        this.height = Math.max(height, MathUtil.EPSILON);
        this.setNeedsUpdate(true);
    }

    @Override
    public double getRadius() {
        return radius;
    }

    @Override
    public void setRadius(double radius) {
        this.radius = Math.max(radius, MathUtil.EPSILON);
        this.setNeedsUpdate(true);
    }

    @Override
    @Contract("-> new")
    public Shape clone() {
        return this.copyTo(new Helix(radius, height, slope, direction));
    }
}
